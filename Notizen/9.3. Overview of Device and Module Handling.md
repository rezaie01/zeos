
## 1. Kurze Inhaltsübersicht

- Der Wechsel von statischer Geräteerstellung (`MAKEDEV`) zu dynamischer (`udev`)1111.
    
- Die Rolle von `sysfs` als Informationsquelle 2und `devtmpfs` als Speicherort für Gerätedateien3.
    
- Der `udevd`-Prozess: Wie Kernel-Events (`uevents`) 44zu Gerätedateien werden5.
    
- Wie `udev` Kernel-Module über Aliase und `modprobe` lädt6.
    
- Typische Probleme und Konfigurationslösungen (z.B. Blacklisting, stabile Namen)77.
    

---

## 2. Minimalistische Zusammenfassung

Früher (traditionell) wurden Gerätedateien unter `/dev` statisch erstellt. Ein `MAKEDEV`-Skript 9erzeugte Tausende von "Nodes" (Gerätedateien), egal ob die Hardware überhaupt vorhanden war.

Heute wird **`udev`** verwendet. `udev` erstellt Gerätedateien dynamisch. Es werden nur Nodes für Geräte angelegt, die der Kernel auch wirklich erkennt. Diese Nodes werden bei jedem Systemstart neu erstellt und liegen in einem `devtmpfs` – einem virtuellen Dateisystem, das komplett im Arbeitsspeicher (RAM) liegt.

Die Basis dafür ist **`sysfs`** (eingeführt mit Kernel 2.6). `sysfs` ist ein virtuelles Dateisystem (meist unter `/sys` gemountet) , das Informationen über die Hardware-Konfiguration an Userspace-Prozesse (wie `udev`) bereitstellt. Treiber registrieren ihre Objekte in `sysfs`, sobald sie vom Kernel erkannt oder als Modul geladen werden.

Der Ablauf der Geräteerstellung ist wie folgt:

1. Der Kernel erstellt eine initiale, minimale Gerätedatei im `devtmpfs` , das auf `/dev` gemountet ist.
    
2. Kurz darauf sendet der Kernel ein **`uevent`** (ein Ereignis) an den `udevd` (den udev-Daemon).
    
3. `udevd` nimmt dieses Event und gleicht es mit Regeln ab.
    
4. Diese Regeln bestimmen, was passiert: z.B. Erstellen von Symlinks, Ändern von Berechtigungen, Besitzer oder Gruppe.
    

Die Regeln werden aus drei Verzeichnissen geladen und zusammengeführt:

- `/usr/lib/udev/rules.d` (Standardregeln)
    
- `/run/udev/rules.d` (Laufzeit-Regeln)
    
- `/etc/udev/rules.d` (Lokale Admin-Regeln, überschreiben die anderen)
    

---

`udev` kümmert sich auch um das **Laden von Kernel-Modulen**27. Module können "Aliase" haben (sichtbar mit `modinfo`). Bus-Treiber (z.B. für PCI oder USB) exportieren diese Aliase via `sysfs` (z.B. in einer `modalias`-Datei)29. Die Standard-Regeln von `udev` rufen dann `/sbin/modprobe` mit diesem Alias auf 30, wodurch das passende Modul geladen wird31.

Dies funktioniert aber nicht für alle Modultypen, z.B. nicht für "Wrapper"-Module wie `snd-pcm-oss`.

---

**Typische Probleme und Konfigurationen:**

- **Problem:** Ein unerwünschtes Modul wird automatisch geladen 33 (z.B. das `forte`-Modul) 34.
    
    - **Lösung:** Blacklisten3535. Dazu in `/etc/modprobe.d/blacklist.conf` eintragen3636:
        
    - `blacklist forte` 37
        
- **Problem:** Ein =="Wrapper"-Modul== (z.B. `snd-pcm-oss`) wird nicht mitgeladen38.
    
    - **Lösung:** Eine "softdep" (weiche Abhängigkeit) in einer `.conf`-Datei unter `/etc/modprobe.d/` definieren3939.
        
    - `softdep snd-pom post: snd-pcm-oss` 4040
        
    - Das lädt `snd-pcm-oss`, _nachdem_ `snd-pom` geladen wurde41414141.
        
- **Problem:** Ein Modul (kein Wrapper) wird gar nicht geladen.
    
    - **Lösung:** Das Modul in die Datei `/etc/sysconfig/modules` eintragen, damit es beim Systemstart geladen wird42.
        
- **Problem:** Gerätenamen (`sda`, `sdb`, `eth0`) ändern sich bei jedem Neustart43.
    
    - **WICHTIG:** Das ist Absicht. `udev` arbeitet parallel, die Reihenfolge ist unvorhersehbar44.
        
    - **Lösung:** Man darf sich **niemals auf diese Kernel-Namen verlassen**45. Stattdessen müssen eigene `udev`-Regeln erstellt werden, die stabile Symlinks basierend auf festen Attributen (z.B. Seriennummer, UUID) erstellen46.
        

---

## 3. Verständnisnotizen

- Ich merke mir: `udev` ist der moderne, dynamische Weg, `/dev` zu verwalten4747. Das alte System war statisch48.
    
- Der Prozess ist: Kernel erkennt Gerät -> schreibt Infos nach `sysfs` 494949-> erstellt Basis-Node in `devtmpfs` 50-> sendet `uevent` 5151-> `udevd` wendet Regeln an52.
    
- `udev` löst auch das Laden von Modulen aus, indem es `modprobe` mit Aliasen aus `sysfs` füttert53.
    
- Für eigene Anpassungen sind `/etc/udev/rules.d` (Regeln) 54und `/etc/modprobe.d/` (Modul-Optionen, Blacklists, Softdeps) 55555555 zentral.
    
- Das Wichtigste: Kernel-Gerätenamen (wie `sda`) sind nicht stabil56. Stabile Namen muss ich selbst über `udev`-Regeln (Symlinks) sicherstellen57.
    
- Wenn ein Treiber von Drittanbietern keine Infos nach `sysfs` exportiert58, kann `udev` nichts tun. Dann muss ich evtl. einen statischen Node in `/usr/lib/udev/devices` anlegen59.
    

---

## Fragen:
### ❓Frage 1: Was ist wirklich der Job von udev? Der Kernel stellt doch schon einen Geräteknoten in /dev, wofür brauchen wir udev?

Antwort:

Du hast recht, der Kernel erstellt über devtmpfs einen ersten, minimalen Geräteknoten1. Dieser hat jedoch nur feste Standard-Berechtigungen (meist für root) und einen festen Namen (z.B. sda)2.

Dieser einfache Knoten reicht für ein modernes System nicht aus. `udev` ist der "intelligente" Verwalter, der diesen Knoten nach der Erstellung durch den Kernel (und dem Empfang eines `uevent`) weiterverarbeitet3:

- **Berechtigungen anpassen:** `udev` ändert den Besitzer, die Gruppe oder die Zugriffsrechte44. So kann z.B. ein normaler Benutzer in der Gruppe `video` auf die Webcam (`/dev/video0`) zugreifen.
    
- **Stabile Namen erstellen (Symlinks):** Die Kernel-Namen wie `sda` oder `sdb` können sich bei jedem Neustart ändern, je nachdem, welche Festplatte schneller erkannt wird5. Das ist unzuverlässig. `udev` erstellt basierend auf stabilen Attributen (wie Seriennummer oder UUID) zuverlässige Symlinks, z.B. unter `/dev/disk/by-uuid/...`66.
    
- **Treiber laden:** `udev` sorgt dafür, dass der passende Treiber (Kernel-Modul) für die Hardware geladen wird7.
    

Der Kernel sagt also nur: "Hier ist _etwas_." `udev` findet heraus: "Ah, das ist _eine bestimmte Festplatte_ von _Hersteller X_, sie gehört _Benutzer Y_, und hier ist der _stabile Name_, den Programme verwenden sollten."

---

### ❓Frage 2: Wo wird das Modul von udevd geladen?

Antwort:

udevd (der udev-Daemon) lädt das Modul nicht direkt selbst. Er stößt den Ladevorgang nur an.

1. Der Kernel sendet ein `uevent` (Ereignis), das eine Hardware-Kennung enthält, den `MODALIAS`8.
    
2. Die Standardregeln von `udev` weisen `udevd` an, bei so einem Event ein externes Programm aufzurufen.
    
3. `udevd` ruft daraufhin den Befehl **`/sbin/modprobe`** auf und übergibt ihm diesen `MODALIAS`9.
    

`/sbin/modprobe` ist das eigentliche Programm, das die Modul-Datenbanken durchsucht und das zum Alias passende Modul in den Kernel lädt.

Frage: ==Wird das Gerät, nach dem `udevd` bearbeitet die Namen, und Berechtigungen, und der Kernel ladet, erneut einhängen?==

---

### ❓Frage 3: Was passiert, nachdem modprobe das Modul geladen hat?

Antwort:

Nachdem modprobe das Modul (den Treiber) erfolgreich in den Kernel geladen hat, passieren zwei Dinge parallel:

1. **Der Treiber wird aktiv:** Das Modul ist jetzt im Kernel. Es "bindet" sich an die Hardware, für die es zuständig ist, und initialisiert sie. Ab diesem Moment weiß der Kernel, wie er mit dem Gerät (z.B. der Soundkarte oder dem USB-Stick) sprechen muss.
    
2. **`udevd` beendet seine Arbeit:** Das Laden des Moduls war nur _eine_ von mehreren Aktionen, die in den `udev`-Regeln standen. `udevd` führt nun die restlichen Aktionen für dieses Gerät aus: Es passt die Berechtigungen an (Besitzer/Gruppe) und erstellt die wichtigen stabilen Symlinks (z.B. unter `/dev/disk/by-id/...`).
    

Wenn all das abgeschlossen ist, ist das Gerät vollständig konfiguriert und einsatzbereit.

---

## 4. Glossar

- **`devfs`**: Ein veralteter Vorgänger von `udev`, der direkt im Kernel lief60. Wurde 2006 entfernt61.
    
- **`devtmpfs`**: Ein virtuelles Dateisystem (im RAM) 62, in das der Kernel die allerersten, grundlegenden Gerätedateien schreibt63, bevor `udev` sie weiterverarbeitet.
    
- **`MAKEDEV`**: Ein altes Skript, das früher `/dev` statisch mit Tausenden von Gerätedateien gefüllt hat64.
    
- **`modalias`**: Ein Alias (Bezeichner) in `sysfs`, der angibt, welches Modul für ein bestimmtes Gerät (z.B. identifiziert durch Vendor- und Device-ID) zuständig ist.
    
- **`modinfo`**: Ein Befehl, der Details über ein Kernel-Modul anzeigt, z.B. auch dessen Aliase.
    
- **`modprobe`**: Der Standardbefehl im Userspace, um Kernel-Module zu laden (und dabei auch Abhängigkeiten aufzulösen) oder zu entfernen67.
    
- **`sysfs`**: Ein virtuelles Dateisystem unter `/sys`68. Es ist das "Fenster" des Kernels, das alle erkannten Geräte, Busse und Treiber als Verzeichnisstruktur für den Userspace sichtbar macht69.
    
- **`udev`**: Das aktuelle System (ein Userspace-Daemon) zur Verwaltung von Gerätedateien in `/dev`70707070.
    
- **`uevent`**: Eine Nachricht (Ereignis) vom Kernel an den Userspace (speziell an `udevd`), die signalisiert, dass ein Gerät hinzugefügt oder entfernt wurde71717171.