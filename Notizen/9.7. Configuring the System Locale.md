#LFS #Systemkonfiguration #Locale #NativeLanguageSupport #Glibc 


### 9.7. Configuring the System Locale (Konfigurieren der System-Lokalisierung)

**Zusammenfassung des Abschnitts:** Ich brauche bestimmte Umgebungsvariablen für die Muttersprachenunterstützung (Native Language Support). Wenn ich die Locale richtig einstelle, werden Programmausgaben übersetzt, Zeichen werden richtig klassifiziert (wichtig, damit Bash Nicht-ASCII-Zeichen in der Kommandozeile akzeptiert), die Sortierreihenfolge ist korrekt, die Standard-Papiergröße passt und Währungs-, Zeit- und Datumswerte werden richtig formatiert.

Ein Locale-Name besteht aus dem zweistelligen Sprachcode (`<ll>`), dem zweistelligen Ländercode (`<CC>`) und der kanonischen Zeichencodierung (`<charmap>`). Optionale Modifikatoren wie `@euro` sind auch möglich. Mit dem Befehl `locale -a` kann ich alle von Glibc unterstützten Locales auflisten. Es ist am sichersten, immer den **kanonischen** Namen für die Zeichencodierung zu wählen, weil manche Programme Probleme mit Aliasen (wie `utf8` statt `UTF-8`) haben. Ich kann den kanonischen Namen mit einem speziellen Befehl bestimmen.

Bevor ich die Locale in die Bash-Startup-Dateien eintrage, muss ich sie testen. Wenn die Testbefehle fehlschlagen und eine bestimmte Fehlermeldung von Glibc kommt, wurde die Locale entweder in Kapitel 8 nicht installiert oder wird von der Standardinstallation nicht unterstützt. In dem Fall muss ich die gewünschte Locale mit dem `localedef`-Befehl installieren oder eine andere wählen. Manchmal funktionieren andere Pakete trotzdem nicht richtig (auch ohne Fehlermeldung), wenn der Locale-Name nicht ihren Erwartungen entspricht. Dann sollte ich mir anschauen, wie andere Linux-Distributionen die Locale unterstützen.

Die Shell `/bin/bash` verwendet Startup-Dateien zur Erstellung der Umgebung. Die Dateien in `/etc` liefern globale Einstellungen, die aber von äquivalenten Dateien in meinem Home-Verzeichnis überschrieben werden können.

**Erklärung der Code/Konfigurations-Abschnitte:**

**CODEBLOCK 4 (Befehl):**

```
locale -a
```

**Erklärung:** Dieser Befehl zeigt eine Liste aller Locales an, die von der Glibc auf dem System unterstützt werden.

**CODEBLOCK 5 (Befehl):**

```
LC_ALL=<locale name> locale charmap
```

**Erklärung:** Dieser Befehl bestimmt den kanonischen Namen der Zeichencodierung (`charmap`) für eine bestimmte, bevorzugte Locale (`<locale name>`), um sicherzustellen, dass ich den korrekten Namen verwende, der von allen Anwendungen erkannt wird.

**CODEBLOCK 6 (Beispiel-Ausgabe):**

```
ISO-8859-1
```

**Erklärung:** Dies ist die beispielhafte Ausgabe des Befehls in Codeblock 5, die den kanonischen Namen der Zeichencodierung für die Locale `en_GB.iso88591` zeigt.

**CODEBLOCK 7 (Befehle):**

```
LC_ALL=<locale name> locale language LC_ALL=<locale name> locale charmap LC_ALL=<locale name> locale int_curr_symbol LC_ALL=<locale name> locale int_prefix
```

**Erklärung:** Diese Befehle dienen dazu, eine neu gewählte Locale zu testen, bevor sie permanent in die Bash-Startup-Dateien übernommen wird. Sie prüfen nacheinander den Sprachnamen, die Zeichencodierung, das lokale Währungssymbol und die internationale Telefonvorwahl für die angegebene Locale.

**CODEBLOCK 8 (Fehlermeldung):**

```
locale: Cannot set LC_* to default locale: No such file or directory
```

**Erklärung:** Diese Meldung erscheint, wenn einer der Testbefehle (Codeblock 7) fehlschlägt und bedeutet, dass die gewünschte Locale entweder nicht im vorherigen Kapitel (Kapitel 8) installiert wurde oder von der Glibc-Standardinstallation nicht unterstützt wird.

## Erstellung der `/etc/profile` (Locale-Einstellungen)

Ich habe gelernt, dass es verschiedene Arten von Shells gibt. Eine *interaktive Login-Shell* startet, wenn ich mich erfolgreich anmelde (sie wird über `/bin/login` gestartet). Eine *interaktive Non-Login-Shell* starte ich direkt an der Kommandozeile. Wenn ein Skript läuft, spricht man von einer *nicht-interaktiven Shell*, da sie nicht auf Benutzereingaben wartet.

Die Datei `/etc/profile` ist wichtig, um die gewünschten *Locale Settings* zu setzen. Aber wenn ich die Linux-Konsole benutze, muss ich die `C.UTF-8` Locale festlegen, damit Programme keine Zeichen ausgeben, die die Konsole nicht anzeigen kann. Ich habe auch gesehen, dass die `C`-Locale (Standard) und die `en_US`-Locale nicht dasselbe sind. Die `C`-Locale nutzt nur das 7-Bit US-ASCII Zeichenset. Wenn 8-Bit-Zeichen auftauchen, ersetzt der `ls`-Befehl sie zum Beispiel durch Fragezeichen. Man soll die `C`-Locale nur verwenden, wenn man sicher ist, niemals 8-Bit-Zeichen zu brauchen.

### Erklärung des Codeblocks:

Der Codeblock dient dazu, die Locale-Einstellungen in die Datei `/etc/profile` zu schreiben.

```
cat > /etc/profile << "EOF" # Begin /etc/profile
for i in $(locale); do   unset ${i%=*} done
if [[ "$TERM" = linux ]]; then   export LANG=C.UTF-8 else   export LANG=<ll>_<CC>.<charmap><@modifiers> fi
# End /etc/profile EOF
```

1.  `cat > /etc/profile << "EOF"`: Hier wird der nachfolgende Text direkt in die Datei `/etc/profile` umgeleitet und geschrieben, bis der Begrenzer `EOF` erreicht wird.
2.  `for i in $(locale); do unset ${i%=*} done`: Dieser Teil löscht zuerst alle vorhandenen oder möglicherweise falsch gesetzten Locale-Umgebungsvariablen.
3.  `if [[ "$TERM" = linux ]]; then export LANG=C.UTF-8`: Hier wird geprüft, ob die Umgebungsvariable `$TERM` auf `linux` gesetzt ist (was bedeutet, dass ich die Linux-Konsole verwende). Wenn ja, wird die Variable `LANG` auf `C.UTF-8` gesetzt, um Darstellungsfehler zu vermeiden.
4.  `else export LANG=<ll>_<CC>.<charmap><@modifiers> fi`: Wenn ich nicht in der Linux-Konsole bin (z. B. in einem Terminal-Emulator), setze ich die `LANG`-Variable auf die gewünschte Standard-Locale des Systems (die Platzhalter müssen noch ersetzt werden).

---

### Glossar

|Begriff|Erklärung|Quelle(n)|
|:--|:--|:--|
|**Bash**|Das Shell-Programm `/bin/bash`, das eine Sammlung von Startup-Dateien (z.B. in `/etc`) verwendet, um die Umgebung zu initialisieren.||
|**Canonical Charset/Charmap**|Der offiziell korrekte Name für eine Zeichencodierung (z.B. `UTF-8` statt `utf8`), der gewählt werden sollte, weil manche Anwendungen Aliase nicht richtig verarbeiten können.||
|**fsck**|Steht für "File System Check". Ein Prozess, der die Dateisysteme beim Booten auf Konsistenz prüft. Ich kann ihn überspringen oder erzwingen.||
|**Glibc**|Die GNU C Library. Sie unterstützt die Locales. Ich kann alle unterstützten Locales mit `locale -a` auflisten.||
|**init**|Das Programm, das beim Herunterfahren zuerst ein `TERM`-Signal sendet, wartet (standardmäßig 3 Sekunden) und dann ein `KILL`-Signal sendet.||
|**KILL/TERM Signal**|Signale, die an Prozesse gesendet werden, um sie zu beenden. `TERM` ist die höfliche Beendigung, `KILL` ist das erzwungene Signal.||
|**Locale**|Ein Satz von Umgebungsvariablen, die notwendig sind, um die Unterstützung der Muttersprache (Native Language Support) zu gewährleisten, inklusive korrekter Formatierung von Datum, Währung und Zeichenklassifizierung.||
|**rc.site**|Die Konfigurationsdatei `/etc/sysconfig/rc.site`, in der ich Anpassungen an den LFS-Boot- und Shutdown-Skripten vornehmen kann.||
|**udev settle**|Ein Aufruf in den `udev`-Boot-Skripten, der eine Wartezeit erfordert, bis alle Geräte initialisiert sind. Kann unter bestimmten Umständen übersprungen werden.||
  