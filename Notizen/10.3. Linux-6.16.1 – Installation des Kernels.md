#LFS #Kernelbau #makeconfig #Modulkonfiguration #UEFI

## 10.3. Linux-6.16.1 – Installation des Kernels

Der Kernel-Bau ist einer der schwierigsten Teile von LFS, weil es fast 12.000 Konfigurationsoptionen gibt. Mein Ziel ist es, eine funktionsfähige Basis zu bekommen, damit ich mich später nach dem Neustart in Abschnitt 11.3 an der Kommandozeile anmelden kann. Optimierung ist im Moment nicht wichtig.

### Vorbereitung und Konfiguration

Zuerst muss ich sicherstellen, dass das Quellverzeichnis des Kernels komplett sauber ist. Die Kernel-Entwickler empfehlen, diesen Befehl vor jeder Kompilierung auszuführen.

```
CODEBLOCK 1:
make mrproper
```

**Erklärung:** Dieser Befehl stellt sicher, dass der Kernel-Baum absolut bereinigt ist und keine alten Build-Dateien enthält.

Um die Konfiguration zu starten, kann ich `make defconfig` verwenden. Das erstellt eine Basis-Konfiguration, die gut auf meine Systemarchitektur abgestimmt ist.

```
CODEBLOCK 4:
make defconfig
```

**Erklärung:** Setzt die Basis-Konfiguration des Kernels (`.config`) basierend auf der Architektur des Systems.

Danach nutze ich das menügesteuerte Interface, um die Konfiguration anzupassen. Falls ich eine UTF-8 Linux Textkonsole verwende, muss ich eventuell die Locale-Einstellungen anpassen, damit die ncurses-Linien korrekt gezeichnet werden.

```
CODEBLOCK 3:
LANG=<host_LANG_value> LC_ALL=
```

**Erklärung:** Setzt die `LANG`-Umgebungsvariable auf den Wert des Hosts (wobei `<host_LANG_value>` ersetzt werden muss) und entfernt `LC_ALL`, um die korrekte Darstellung der `menuconfig`-Oberfläche zu gewährleisten.

```
CODEBLOCK 2:
make menuconfig
```

**Erklärung:** Startet die menügesteuerte ncurses-Oberfläche, um die Kernel-Optionen auszuwählen.

#### Wichtige Konfigurationseinstellungen

Ich muss einige spezifische Optionen setzen, damit das System später korrekt funktioniert und startet:

- **ASLR und Sicherheit:** `Randomize the address of the kernel image (KASLR)` muss aktiviert sein, um Angriffe auf fixe Adressen im Kernel abzuwehren. `Strong Stack Protector` muss aktiviert werden, da der Kernel nicht die Standard-SSP-Einstellungen von GCC verwendet.
- **Geräteverwaltung:** Ich muss `Maintain a devtmpfs filesystem to mount at /dev` und `Automount devtmpfs at /dev` aktivieren. Das sorgt dafür, dass der Kernel automatisch Geräteknoten erstellt, noch bevor Udev läuft, was für alle Udev-Benutzer notwendig ist. Außerdem darf ich `Support for uevent helper` nicht aktivieren, da dies die Geräteverwaltung mit Udev stören kann.
- **Grafik und Konsolen-Panic:** Ich aktiviere verschiedene Optionen für die Grafikunterstützung (`DRM`, `Simple framebuffer driver`) und die Konsolendarstellung (`Framebuffer Console support`), um eine leere Anzeige zu verhindern, sobald ein DRI-Treiber geladen wird. Besonders wichtig ist die Aktivierung von `Display a user-friendly message when a kernel panic occurs` und die Auswahl von `kmsg` als Panic Screen Formatter, damit ich im Falle eines Kernel Panics (z. B. durch falsche `root=` Einstellung) die letzten wichtigen Kernel-Nachrichten sehen kann.
- **64-Bit:** Bei 64-Bit-Systemen aktiviere ich `x2APIC interrupt controller support`. Auch wenn x2APIC von der Firmware deaktiviert ist, schadet es nicht; ist es jedoch aktiviert und der Kernel unterstützt es nicht, kommt es zum Panic.
- **UEFI:** Falls ich UEFI verwende, muss ich zusätzlich Kernel-Optionen anpassen (die im BLFS-Handbuch beschrieben sind).

### Kompilierung und Installation

Nach der Konfiguration kompiliere ich den Kernel und die Module:

```
CODEBLOCK 5:
make
```

**Erklärung:** Führt die Kompilierung des Kernels durch.

Anschließend installiere ich die Module, es sei denn, ich habe die Modulunterstützung komplett deaktiviert.

```
CODEBLOCK 6:
make modules_install
```

**Erklärung:** Installiert die kompilierten Kernel-Module in das Verzeichnis `/lib/modules`.

### Kopieren der Kernel-Dateien

Falls ich eine separate `/boot`-Partition benutze, muss ich sie zuerst mounten.

```
CODEBLOCK 7:
mount /boot
```

**Erklärung:** Mountet die `/boot`-Partition. Der Pfad zum Gerät wird aus `/etc/fstab` gelesen.

Jetzt kopiere ich die Kernel-Dateien in das `/boot`-Verzeichnis:

```
CODEBLOCK 8:
cp -iv arch/x86/boot/bzImage /boot/vmlinuz-6.16.1-lfs-12.4
```

**Erklärung:** Kopiert das Kernel-Image (`bzImage` für x86) nach `/boot`. Der Dateiname sollte `vmlinuz` enthalten, um mit dem automatischen Bootprozess kompatibel zu sein.

```
CODEBLOCK 9:
cp -iv System.map /boot/System.map-6.16.1
```

**Erklärung:** Kopiert die Symbol-Datei (`System.map`), die Adressen und Symbole des Kernels abbildet und für die Untersuchung von Kernel-Problemen wichtig ist.

```
CODEBLOCK 10:
cp -iv .config /boot/config-6.16.1
```

**Erklärung:** Kopiert die erstellte Konfigurationsdatei (`.config`) nach `/boot`, um sie für zukünftige Referenzen aufzubewahren.

Zusätzlich installiere ich die Kernel-Dokumentation:

```
CODEBLOCK 11:
cp -r Documentation -T /usr/share/doc/linux-6.16.1
```

**Erklärung:** Kopiert das gesamte Verzeichnis `Documentation` in den Systempfad für Dokumentationen.

Wenn ich den Kernel-Quellbaum behalten möchte, muss ich sicherstellen, dass alle Dateien dem Benutzer `root` gehören, falls sie unter `root` entpackt wurden. Ich muss aber **keinen** Symlink von `/usr/src/linux` erstellen, da dies Probleme verursachen kann. Wenn ich GCC aktualisiert habe, muss ich unbedingt `make clean` ausführen, sonst kann der neue Build fehlschlagen.

```
CODEBLOCK 12:
make clean
```

**Erklärung:** Löscht alle Objektdateien (`.o`) und ist notwendig, wenn ich den Kernel nach einem GCC-Upgrade neu kompilieren muss.

## 10.3.2. Konfigurieren der Linux-Modul-Ladereihenfolge

Normalerweise werden Module automatisch geladen, aber manchmal braucht es spezifische Anweisungen, um Warnungen zu vermeiden. Das Programm `modprobe` nutzt dazu Konfigurationsdateien in `/etc/modprobe.d`.

Ich muss eine Konfigurationsdatei für die USB-Treiber erstellen, damit der `ehci_hcd` (der USB-3.0-Treiber) vor den älteren `ohci_hcd` und `uhci_hcd` geladen wird.

```
CODEBLOCK 13:
install -v -m755 -d /etc/modprobe.d
```

**Erklärung:** Erstellt das Verzeichnis `/etc/modprobe.d` mit den Berechtigungen 755.

```
CODEBLOCK 14:
cat > /etc/modprobe.d/usb.conf << "EOF" # Begin /etc/modprobe.d/usb.conf
install ohci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i ohci_hcd ; true install uhci_hcd /sbin/modprobe ehci_hcd ; /sbin/modprobe -i uhci_hcd ; true
# End /etc/modprobe.d/usb.conf EOF
```

**Erklärung:** Erstellt die Datei `/etc/modprobe.d/usb.conf`. Die `install`-Zeilen sorgen dafür, dass beim Versuch, `ohci_hcd` oder `uhci_hcd` zu laden, zuerst der `ehci_hcd` geladen wird, um eine korrekte Reihenfolge und die Vermeidung von Boot-Warnungen zu gewährleisten.

## Glossar

|Begriff|Erklärung (LFS-Kontext)|
|:--|:--|
|**SBU**|System Build Unit, eine ungefähre Zeiteinheit, um die Dauer des Bauprozesses relativ zu einer Basis-Kompilierung abzuschätzen.|
|**`make mrproper`**|Befehl zur vollständigen Bereinigung des Kernel-Quellbaums, empfohlen vor jeder Neukompilierung.|
|**`make menuconfig`**|Menügesteuertes Interface (ncurses-basiert) zur interaktiven Konfiguration des Kernels.|
|**`make defconfig`**|Erstellt eine Basis-Konfigurationsdatei, die auf der Architektur des aktuellen Systems basiert.|
|**KASLR**|Kernel Address Space Layout Randomization. Aktiviert die Zufallsgenerierung der Kernel-Adresse, um Sicherheitsangriffe zu minimieren.|
|**SSP**|Stack Protector. Wird explizit für den Kernel aktiviert, um Pufferüberlaufangriffe zu verhindern (`Strong Stack Protector`).|
|**`devtmpfs`**|Ein Dateisystem, das Geräteknoten automatisch im `/dev`-Verzeichnis durch den Kernel erstellt, was vor dem Start von Udev notwendig ist.|
|**`vmlinuz`**|Die empfohlene Namenskonvention für das komprimierte und bootfähige Kernel-Image, das nach `/boot` kopiert wird.|
|**`System.map`**|Eine Symbol-Datei, die Adressen und Funktions-Entry-Points des Kernels auflistet. Hilfreich bei der Diagnose von Kernel-Problemen.|
|**`modprobe.d`**|Verzeichnis unter `/etc`, das Konfigurationsdateien für das Laden von Kernel-Modulen enthält, um die Ladereihenfolge zu steuern.|
|**x2APIC**|Eine erweiterte Interrupt-Controller-Architektur, die auf 64-Bit-x86-Systemen unterstützt werden muss.|

***

# NOTES: 

1. wenn das / (root) Verzeichnis eine NVME Partition ist, denn soll die Kerneloption: `NVM Express block device` nicht als Module (`<M>`), sondern als ein statischer Treiber (`<*>`) gewählt werden. 
   