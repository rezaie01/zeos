# Installation von GCC - Durchlauf 2

Zuerst werden die erforderlichen Abhängigkeiten (MPFR, GMP und MPC) vorbereitet und Verzeichnisse für den Bau eingerichtet.


```bash
tar -xf ../mpfr-4.2.2.tar.xz
mv -v mpfr-4.2.2 mpfr
tar -xf ../gmp-6.3.0.tar.xz
mv -v gmp-6.3.0 gmp
tar -xf ../mpc-1.3.1.tar.gz
mv -v mpc-1.3.1 mpc
```
> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> 
> `tar -xf ../<paket>.tar.*`: Entpackt die Archivdateien (`tar -x` zum Extrahieren, `-f` für die Angabe der Datei, `-z`/`-j`/`-J` wird von `tar` automatisch erkannt oder ist in diesem Fall nicht nötig, da `-f` ausreicht). Die Dateien befinden sich im übergeordneten Verzeichnis (`..`).
> 
> `mv -v <verzeichnis> <ziel>`: Benennt das entpackte Verzeichnis um (`mv`) in einen einfacheren Namen (z. B. `mpfr-4.2.2` zu `mpfr`). Die Option `-v` zeigt den Vorgang an.
> 
> **Zweck:** GCC benötigt diese Mehrfachpräzisionsbibliotheken (MPFR, GMP, MPC), um ordnungsgemäß kompiliert werden zu können. Das Umbenennen der Verzeichnisse in einfache Namen (`mpfr`, `gmp`, `mpc`) ist eine **Voraussetzung** für das GCC-Build-System, da es erwartet, diese in seinen Quellen zu finden.

---

## x86_64 Anpassung


```Bash
case $(uname -m) in
 x86_64)
 sed -e '/m64=/s/lib64/lib/' \
 -i.orig gcc/config/i386/t-linux64
 ;;
esac
```
> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> 
> `case $(uname -m) in x86_64)`: Prüft, ob die Architektur des laufenden Systems **x86_64** ist (also ein 64-Bit-System).
> 
> `sed -e '/m64=/s/lib64/lib/'`: Führt eine **`sed`**-Ersetzung durch. Es sucht nach der Zeile, die **`/m64=`** enthält, und ersetzt darin die Zeichenkette **`lib64`** durch **`lib`**.
> 
> `-i.orig gcc/config/i386/t-linux64`: Führt die Änderung direkt in der Datei **`gcc/config/i386/t-linux64`** aus (`-i`) und erstellt eine Sicherungskopie der Originaldatei mit der Endung `.orig`.
> 
> **Zweck:** Auf 64-Bit-Systemen verwendet der GCC-Build-Prozess standardmäßig `lib64` für die 64-Bit-Bibliotheken. In LFS werden jedoch alle Bibliotheken (auch 64-Bit) in **`/usr/lib`** abgelegt (daher die Umstellung auf `lib`). Dieser Schritt stellt sicher, dass der Compiler die Bibliotheken im richtigen, LFS-konformen Pfad sucht.

---

## Threading-Anpassung



```Bash
sed '/thread_header =/s/@.\*@/gthr-posix.h/' \
 -i libgcc/Makefile.in libstdc++-v3/include/Makefile.in
```
> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> 
> `sed '/thread_header =/s/@.\*@/gthr-posix.h/'`: Sucht in der Datei nach der Zeile, die mit **`thread_header =`** beginnt, und ersetzt den Wert zwischen den `@`-Zeichen (`@.*@`) durch **`gthr-posix.h`**.
> 
> `-i ...`: Führt die Änderung in den Dateien **`libgcc/Makefile.in`** und **`libstdc++-v3/include/Makefile.in`** durch.
> 
> **Zweck:** Überschreibt die Standard-Build-Regeln für die Header-Dateien von `libgcc` und `libstdc++`, um sicherzustellen, dass die Bibliotheken mit **POSIX Threads** (`gthr-posix.h`) anstelle der standardmäßigen Host-Threads gebaut werden. Dies ist für eine konsistente Toolchain unerlässlich.

---

### Konfiguration und Kompilierung



```Bash
mkdir -v build
cd build
```

> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> 
> `mkdir -v build`: Erstellt ein neues Verzeichnis namens `build` (`-v` zeigt die Erstellung an).
> 
> `cd build`: Wechselt in dieses neue Verzeichnis.
> 
> **Zweck:** Wie üblich in LFS wird das Kompilieren außerhalb des Quellverzeichnisses durchgeführt (Out-of-Tree Build), um das Quellverzeichnis sauber zu halten.

---

#### GCC `configure`-Befehl



```Bash
../configure \
 --build=$(../config.guess) \
 --host=$LFS_TGT \
 --target=$LFS_TGT \
 --prefix=/usr \
 --with-build-sysroot=$LFS \
 --enable-default-pie \
 --enable-default-ssp \
 --disable-nls \
 --disable-multilib \
 --disable-libatomic \
 --disable-libgomp \
 --disable-libquadmath \
 --disable-libsanitizer \
 --disable-libssp \
 --disable-libvtv \
 --enable-languages=c,c++ \
 LDFLAGS_FOR_TARGET=-L$PWD/$LFS_TGT/libgcc
```
> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> `\ --host=$LFS_TGT`: Gibt das **Host-System** an (das System, auf dem die kompilierten Programme laufen sollen - die temporäre Toolchain). `$LFS_TGT` ist der Cross-Compile-Triple (z.B. `x86_64-lfs-linux-gnu`).
> 
> `\ --target=$LFS_TGT`: **WICHTIG.** Da dies der zweite Durchlauf (Pass 2) des Compilers ist, wird GCC als **Cross-Compiler** _und_ als **Ziel-Compiler** (Native Compiler) konfiguriert, der Programme für sich selbst (`$LFS_TGT`) erstellt. Dies stellt sicher, dass die **Ziel-Bibliotheken** (`libgcc`, `libstdc++`) mit dem GCC-Pass-1-Compiler gebaut werden, der bereits im LFS-Verzeichnis liegt.
> 
> `\ --prefix=/usr`: Installiert die finalen GCC-Programme in das Zielsystem (`$LFS`) im Verzeichnis **`/usr`**.
> 
> `\ --with-build-sysroot=$LFS`:
> 
> - Weist dem GCC-Build-System an, nach Bibliotheken und Headern im **`$LFS`**-Verzeichnis zu suchen.
>     
> - Dies stellt sicher, dass die GCC-internen Tools und das `configure`-Skript die temporären LFS-Tools (wie `glibc`, die in Pass 1 installiert wurden) finden, anstatt die Header des Host-Systems zu verwenden.
>     
> `\ --enable-default-pie`: Aktiviert standardmäßig **Position Independent Executables** (PIE), was eine Sicherheitsfunktion ist.
> 
> `\ --enable-default-ssp`: Aktiviert standardmäßig **Stack Smashing Protection** (SSP), eine weitere Sicherheitsfunktion gegen Pufferüberläufe.
> 
> `\ --disable-nls`: Deaktiviert **Native Language Support** (Übersetzungsunterstützung).
> 
> `\ --disable-multilib`: Deaktiviert die Unterstützung für das Erstellen von Bibliotheken für mehrere Architekturen (z. B. 32- und 64-Bit-Versionen gleichzeitig).
> 
> `\ --disable-libatomic` / `\ --disable-libgomp` / ...: Deaktiviert die Erstellung verschiedener unterstützender GCC-Laufzeitbibliotheken (wie OpenMP, Go-Programmiermodell-Unterstützung, Adresssanitizer etc.), da diese für die minimale LFS-Toolchain nicht benötigt werden.
> 
> `\ --enable-languages=c,c++`: Konfiguriert GCC nur für die Unterstützung der Sprachen **C** und **C++**.
> 
> `LDFLAGS_FOR_TARGET=-L$PWD/$LFS_TGT/libgcc`:
> 
> - Diese Variable wird während des Builds der Zielbibliotheken (insbesondere `libstdc++`) verwendet.
>     
> - Sie stellt sicher, dass der **Linker** die **`libgcc`**-Bibliothek findet, die gerade in diesem Durchlauf (`Pass 2`) im Build-Verzeichnis erstellt wird, anstatt die ältere Version von `Pass 1` zu verwenden.
>     
> - Dies ist notwendig, damit `libstdc++` die korrekte Ausnahmebehandlung (C++ exception handling) unterstützen kann.

## Compilieren

```bash
make
```

## Installieren

```bash
make DESTDIR=$LFS install
```

## Das `cc` erstellen:

```bash

ln -sv gcc $LFS/usr/bin/cc

```
> **<font color="#9bbb59">ERKLÄRUNG:</font>**
> `$LFS/usr/bin/cc`: Dies ist das **Ziel** der Verknüpfung.
> 
> **Zweck:** In vielen Unix-Systemen (und LFS ist keine Ausnahme) wird der Standard-C-Compiler, auch als **`cc`** bekannt, durch einen symbolischen Link auf den tatsächlichen C-Compiler (`gcc`) bereitgestellt. Dieser Befehl erstellt diesen Link im finalen LFS-Tool-Verzeichnis, um sicherzustellen, dass Build-Skripte und Programme, die explizit `cc` aufrufen, korrekt auf den neu erstellten Cross-Compiler verweisen, der jetzt für die Erstellung der restlichen temporären Werkzeuge verwendet wird.
>
> Der Quellpfad (`gcc`) ist ein **relativer Pfad**.
>- Der Link `$LFS/usr/bin/cc` wird auf den Pfad `gcc` zeigen.
    >
>- Wenn du diesen Link aufrufst, sucht das System nach der Datei `gcc` **relativ zum Verzeichnis, in dem der Link erstellt wird** (in diesem Fall `$LFS/usr/bin`).
    >
>- Da der Link _in_ `$LFS/usr/bin` liegt, wird der Link intern auf **`./gcc`** zeigen. Das ist **korrekt** für LFS-Zwecke, da es den Link portabler macht, falls du den `$LFS`-Mountpunkt verschiebst.



